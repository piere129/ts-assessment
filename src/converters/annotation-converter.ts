import { ConvertedAnnotation, Index, Annotation, ConvertedItemMap, ConvertedEntity, ConvertedItem } from '../types';
import { BaseConverter } from './base-converter';

interface ConvertedAnnotationDataObject extends ConvertedAnnotation {
  indices?: null | Index[];
}

export class AnnotationConverter extends BaseConverter<ConvertedAnnotation> {
  private mapAnnotationPropsToConvertedAnnotationDataObject(
    annotation: Annotation,
    entityHashMap: ConvertedItemMap<ConvertedEntity>,
  ): ConvertedAnnotationDataObject {
    return {
      id: annotation.id,
      value: annotation.value,
      entity: { id: annotation.entityId, name: entityHashMap[annotation.entityId].name },
      index: annotation.indices && annotation.indices.length > 0 ? annotation.indices[0].start : -1,
      indices: annotation.indices,
      children: [],
    };
  }

  private findMinimumIndexRecursive(dataobject: ConvertedAnnotationDataObject): number {
    if (dataobject.indices && dataobject.indices.length > 0) {
      return dataobject.indices[0].start;
    }

    if (dataobject.children.length > 0) {
      return Math.min(
        ...dataobject.children.map((value: ConvertedItem<ConvertedAnnotation>) =>
          this.findMinimumIndexRecursive(value as ConvertedAnnotationDataObject),
        ),
      );
    }

    return Number.MAX_SAFE_INTEGER;
  }

  public convertAnnotations(
    annotations: Annotation[],
    entityHashMap: ConvertedItemMap<ConvertedEntity>,
  ): ConvertedAnnotation[] {
    // a hashTable to track the actual eventual item to set the index on
    const convertedAnnotationHashTable: ConvertedItemMap<ConvertedAnnotationDataObject> = Object.create(null);
    // a nested temporary hashTable as reference, to get the actual index by travelling down the indices property
    const convertedAnnotationHashTableNested: ConvertedItemMap<ConvertedAnnotationDataObject> = Object.create(null);

    // fill up the hashTables
    annotations.forEach((annotation: Annotation) => {
      // create twice to avoid reference issues
      convertedAnnotationHashTable[annotation.id] = this.mapAnnotationPropsToConvertedAnnotationDataObject(
        annotation,
        entityHashMap,
      );
      convertedAnnotationHashTableNested[annotation.id] = this.mapAnnotationPropsToConvertedAnnotationDataObject(
        annotation,
        entityHashMap,
      );
    });

    const noIndiceAnnotationIds: string[] = [];

    annotations.forEach((annotation: Annotation) => {
      // setup tree structure in nested hashtable
      if (annotation.refs.length > 0) {
        annotation.refs.forEach((parentId: string) => {
          convertedAnnotationHashTableNested[parentId].children.push(convertedAnnotationHashTable[annotation.id]);
        });
      }

      // if no indices, keep track of id of items where index will have to be generated by checking children
      if (!annotation.indices || annotation.indices.length === 0) {
        noIndiceAnnotationIds.push(annotation.id);
      }
    });

    // find lowest index in children and assign it to the convertedAnnotationHashTable
    noIndiceAnnotationIds.forEach((id: string) => {
      const annotationInNestedMap = convertedAnnotationHashTableNested[id];
      const index = this.findMinimumIndexRecursive(annotationInNestedMap);
      convertedAnnotationHashTable[id].index = index;
    });

    // clear indices, as they are no longer needed
    Object.values(convertedAnnotationHashTable).forEach((value: ConvertedAnnotationDataObject) => {
      delete value.indices;
    });

    // add the correct children structure to the convertedAnnotationHashTable
    annotations.forEach((annotation: Annotation) => {
      if (annotation.refs.length > 0) {
        annotation.refs.forEach((parentId: string) => {
          convertedAnnotationHashTable[parentId].children.push(convertedAnnotationHashTable[annotation.id]);
          delete convertedAnnotationHashTable[annotation.id];
        });
      }
    });

    return Object.values(convertedAnnotationHashTable);
  }

  public sortAnnotationsByIndexAsc(annotationA: ConvertedAnnotation, annotationB: ConvertedAnnotation): number {
    return annotationA.index - annotationB.index;
  }

  public sortConvertedAnnotations = (
    annotations: ConvertedAnnotation[],
    sortFunc: (annotationA: ConvertedAnnotation, annotationB: ConvertedAnnotation) => number,
  ): ConvertedAnnotation[] => {
    return super.sortItems<ConvertedAnnotation>(annotations, sortFunc);
  };
}
